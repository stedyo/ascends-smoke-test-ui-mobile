"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateDistributionCertificate = validateDistributionCertificate;
exports.CreateOrReuseDistributionCert = exports.UseExistingDistributionCert = exports.UpdateIosDist = exports.RemoveIosDist = exports.CreateIosDist = void 0;

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _dateformat() {
  const data = _interopRequireDefault(require("dateformat"));

  _dateformat = function () {
    return data;
  };

  return data;
}

function _get() {
  const data = _interopRequireDefault(require("lodash/get"));

  _get = function () {
    return data;
  };

  return data;
}

function _ora() {
  const data = _interopRequireDefault(require("ora"));

  _ora = function () {
    return data;
  };

  return data;
}

function _inquirer() {
  const data = _interopRequireDefault(require("inquirer"));

  _inquirer = function () {
    return data;
  };

  return data;
}

function _xdl() {
  const data = require("@expo/xdl");

  _xdl = function () {
    return data;
  };

  return data;
}

function _prompt() {
  const data = _interopRequireDefault(require("../../prompt"));

  _prompt = function () {
    return data;
  };

  return data;
}

function _log() {
  const data = _interopRequireDefault(require("../../log"));

  _log = function () {
    return data;
  };

  return data;
}

function _credentials() {
  const data = require("../credentials");

  _credentials = function () {
    return data;
  };

  return data;
}

function _promptForCredentials() {
  const data = require("../actions/promptForCredentials");

  _promptForCredentials = function () {
    return data;
  };

  return data;
}

function _list() {
  const data = require("../actions/list");

  _list = function () {
    return data;
  };

  return data;
}

function _appleApi() {
  const data = require("../../appleApi");

  _appleApi = function () {
    return data;
  };

  return data;
}

function _IosProvisioningProfile() {
  const data = require("./IosProvisioningProfile");

  _IosProvisioningProfile = function () {
    return data;
  };

  return data;
}

function _route() {
  const data = require("../route");

  _route = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const APPLE_DIST_CERTS_TOO_MANY_GENERATED_ERROR = `
You can have only ${_chalk().default.underline('three')} Apple Distribution Certificates generated on your Apple Developer account.
Please revoke the old ones or reuse existing from your other apps.
Please remember that Apple Distribution Certificates are not application specific!
`;

class CreateIosDist {
  async create(ctx) {
    const newDistCert = await this.provideOrGenerate(ctx);
    return await ctx.ios.createDistCert(newDistCert);
  }

  async open(ctx) {
    const distCert = await this.create(ctx);
    (0, _log().default)(_chalk().default.green('Successfully created Distribution Certificate\n'));
    (0, _list().displayIosUserCredentials)(distCert);
    (0, _log().default)();
    return null;
  }

  async provideOrGenerate(ctx) {
    const userProvided = await promptForDistCert(ctx);

    if (userProvided) {
      if (!ctx.hasAppleCtx()) {
        (0, _log().default)(_chalk().default.yellow("WARNING! Unable to validate Distribution Certificate due to insufficient Apple Credentials. Please double check that you're uploading valid files for your app otherwise you may encounter strange errors!"));
        return userProvided;
      }

      const isValid = await validateDistributionCertificate(ctx.appleCtx, userProvided);
      return isValid ? userProvided : await this.provideOrGenerate(ctx);
    }

    return await generateDistCert(ctx);
  }

}

exports.CreateIosDist = CreateIosDist;

class RemoveIosDist {
  constructor(shouldRevoke = false) {
    this.shouldRevoke = shouldRevoke;
  }

  async open(ctx) {
    const selected = await selectDistCertFromList(ctx);

    if (selected) {
      await this.removeSpecific(ctx, selected);
      (0, _log().default)(_chalk().default.green('Successfully removed Distribution Certificate\n'));
      return null;
    }

    throw new (_route().GoBackError)();
  }

  async removeSpecific(ctx, selected) {
    const apps = ctx.ios.credentials.appCredentials.filter(cred => cred.distCredentialsId === selected.id);
    const appsList = apps.map(appCred => _chalk().default.green(appCred.experienceName)).join(', ');

    if (appsList) {
      const {
        confirm
      } = await (0, _prompt().default)([{
        type: 'confirm',
        name: 'confirm',
        message: `You are removing certificate used by ${appsList}. Do you want to continue?`
      }]);

      if (!confirm) {
        (0, _log().default)('Aborting');
        return;
      }
    }

    await ctx.ios.deleteDistCert(selected.id);
    let shouldRevoke = false;

    if (selected.certId) {
      const {
        revoke
      } = await (0, _prompt().default)([{
        type: 'confirm',
        name: 'revoke',
        message: `Do you also want to revoke it on Apple Developer Portal?`,
        when: !this.shouldRevoke
      }]);

      if (revoke || this.shouldRevoke) {
        await ctx.ensureAppleCtx();
        await new (_appleApi().DistCertManager)(ctx.appleCtx).revoke([selected.certId]);
      }

      shouldRevoke = revoke;
    }

    for (const appCredentials of apps) {
      (0, _log().default)(`Removing Provisioning Profile for ${appCredentials.experienceName} (${appCredentials.bundleIdentifier})`);
      await new (_IosProvisioningProfile().RemoveProvisioningProfile)(shouldRevoke || this.shouldRevoke).removeSpecific(ctx, appCredentials);
    }
  }

}

exports.RemoveIosDist = RemoveIosDist;

class UpdateIosDist {
  async open(ctx) {
    const selected = await selectDistCertFromList(ctx);

    if (selected) {
      await this.updateSpecific(ctx, selected);
      (0, _log().default)(_chalk().default.green('Successfully updated Distribution Certificate\n'));
      const updated = ctx.ios.credentials.userCredentials.find(i => i.id === selected.id);

      if (updated) {
        (0, _list().displayIosUserCredentials)(updated);
      }

      (0, _log().default)();
      return null;
    }

    throw new (_route().GoBackError)();
  }

  async updateSpecific(ctx, selected) {
    const apps = ctx.ios.credentials.appCredentials.filter(cred => cred.distCredentialsId === selected.id);
    const appsList = apps.map(appCred => _chalk().default.green(appCred.experienceName)).join(', ');

    if (apps.length > 1) {
      const question = {
        type: 'confirm',
        name: 'confirm',
        message: `You are updating certificate used by ${appsList}. Do you want to continue?`
      };
      const {
        confirm
      } = await (0, _prompt().default)(question);

      if (!confirm) {
        (0, _log().default)('Aborting update process');
        return;
      }
    }

    const newDistCert = await this.provideOrGenerate(ctx);
    await ctx.ensureAppleCtx();
    const updatedUserCredentials = await ctx.ios.updateDistCert(selected.id, { ...newDistCert,
      teamId: ctx.appleCtx.team.id,
      teamName: ctx.appleCtx.team.name
    });

    for (const appCredentials of apps) {
      (0, _log().default)(`Removing Provisioning Profile for ${appCredentials.experienceName} (${appCredentials.bundleIdentifier})`);
      await new (_IosProvisioningProfile().RemoveProvisioningProfile)(true).removeSpecific(ctx, appCredentials);
    }
  }

  async provideOrGenerate(ctx) {
    const userProvided = await promptForDistCert(ctx);

    if (userProvided) {
      if (!ctx.hasAppleCtx()) {
        (0, _log().default)(_chalk().default.yellow("WARNING! Unable to validate Distribution Certificate due to insufficient Apple Credentials. Please double check that you're uploading valid files for your app otherwise you may encounter strange errors!"));
        return userProvided;
      }

      const isValid = await validateDistributionCertificate(ctx.appleCtx, userProvided);
      return isValid ? userProvided : await this.provideOrGenerate(ctx);
    }

    return await generateDistCert(ctx);
  }

}

exports.UpdateIosDist = UpdateIosDist;

class UseExistingDistributionCert {
  constructor(options) {
    const {
      experienceName,
      bundleIdentifier
    } = options;
    this._experienceName = experienceName;
    this._bundleIdentifier = bundleIdentifier;
  }

  static withProjectContext(ctx) {
    if (!ctx.hasProjectContext) {
      _log().default.error('Can only be used in project context');

      return null;
    }

    const options = getOptionsFromProjectContext(ctx);
    if (!options) return null;
    return new UseExistingDistributionCert(options);
  }

  async open(ctx) {
    const selected = await selectDistCertFromList(ctx, {
      filterInvalid: true
    });

    if (selected) {
      await ctx.ios.useDistCert(this._experienceName, this._bundleIdentifier, selected.id);
      (0, _log().default)(_chalk().default.green(`Successfully assigned Distribution Certificate to ${this._experienceName} (${this._bundleIdentifier})`));
      return null;
    }

    throw new (_route().GoBackError)();
  }

}

exports.UseExistingDistributionCert = UseExistingDistributionCert;

class CreateOrReuseDistributionCert {
  constructor(options) {
    const {
      experienceName,
      bundleIdentifier
    } = options;
    this._experienceName = experienceName;
    this._bundleIdentifier = bundleIdentifier;
    this._credentialsManager = _route().CredentialsManager.get();
  }

  async assignDistCert(ctx, userCredentialsId) {
    await ctx.ios.useDistCert(this._experienceName, this._bundleIdentifier, userCredentialsId);
    (0, _log().default)(_chalk().default.green(`Successfully assigned Distribution Certificate to ${this._experienceName} (${this._bundleIdentifier})`));
  }

  async open(ctx) {
    if (!ctx.user) {
      throw new Error(`This workflow requires you to be logged in.`);
    }

    const existingCertificates = await getValidDistCerts(ctx.ios.credentials, ctx.appleCtx);

    if (existingCertificates.length === 0) {
      const createOperation = async () => new CreateIosDist().create(ctx);

      const distCert = await this._credentialsManager.doInteractiveOperation(createOperation, this);
      await this.assignDistCert(ctx, distCert.id);
      return null;
    } // autoselect creds if we find valid certs


    const autoselectedCertificate = existingCertificates[0];
    const confirmQuestion = {
      type: 'confirm',
      name: 'confirm',
      message: `${formatDistCert(autoselectedCertificate, ctx.ios.credentials, 'VALID')} \n Would you like to use this certificate?`,
      pageSize: Infinity
    };
    const {
      confirm
    } = await (0, _prompt().default)(confirmQuestion);

    if (confirm) {
      (0, _log().default)(`Using Distribution Certificate: ${autoselectedCertificate.certId}`);
      await this.assignDistCert(ctx, autoselectedCertificate.id);
      return null;
    }

    const choices = [{
      name: '[Choose existing certificate] (Recommended)',
      value: 'CHOOSE_EXISTING'
    }, {
      name: '[Add a new certificate]',
      value: 'GENERATE'
    }, {
      name: '[Go back]',
      value: 'GO_BACK'
    }];
    const question = {
      type: 'list',
      name: 'action',
      message: 'Select an iOS distribution certificate to use for code signing:',
      choices,
      pageSize: Infinity
    };
    const {
      action
    } = await (0, _prompt().default)(question);

    if (action === 'GENERATE') {
      const createOperation = async () => new CreateIosDist().create(ctx);

      const distCert = await this._credentialsManager.doInteractiveOperation(createOperation, this);
      await this.assignDistCert(ctx, distCert.id);
      return null;
    } else if (action === 'CHOOSE_EXISTING') {
      return new UseExistingDistributionCert({
        bundleIdentifier: this._bundleIdentifier,
        experienceName: this._experienceName
      });
    } else {
      throw new (_route().GoBackError)(); // go back
    }
  }

}

exports.CreateOrReuseDistributionCert = CreateOrReuseDistributionCert;

function getOptionsFromProjectContext(ctx) {
  const experience = (0, _get().default)(ctx, 'manifest.slug');
  const owner = (0, _get().default)(ctx, 'manifest.owner');
  const experienceName = `@${owner || ctx.user.username}/${experience}`;
  const bundleIdentifier = (0, _get().default)(ctx, 'manifest.ios.bundleIdentifier');

  if (!experience || !bundleIdentifier) {
    _log().default.error(`slug and ios.bundleIdentifier needs to be defined`);

    return null;
  }

  return {
    experienceName,
    bundleIdentifier
  };
}

async function getValidDistCerts(iosCredentials, appleCtx) {
  const distCerts = iosCredentials.userCredentials.filter(cred => cred.type === 'dist-cert');

  if (!appleCtx) {
    (0, _log().default)(_chalk().default.yellow(`Unable to determine validity of Distribution Certificates.`));
    return distCerts;
  }

  const distCertManager = new (_appleApi().DistCertManager)(appleCtx);
  const certInfoFromApple = await distCertManager.list();
  const validCerts = await filterRevokedDistributionCerts(certInfoFromApple, distCerts);
  return sortByExpiryDesc(certInfoFromApple, validCerts);
}

function getValidityStatus(distCert, validDistCerts) {
  if (!validDistCerts) {
    return 'UNKNOWN';
  }

  return validDistCerts.includes(distCert) ? 'VALID' : 'INVALID';
}

async function selectDistCertFromList(ctx, options = {}) {
  const iosCredentials = ctx.ios.credentials;
  let distCerts = iosCredentials.userCredentials.filter(cred => cred.type === 'dist-cert');
  let validDistCerts = null;

  if (ctx.hasAppleCtx()) {
    const distCertManager = new (_appleApi().DistCertManager)(ctx.appleCtx);
    const certInfoFromApple = await distCertManager.list();
    validDistCerts = await filterRevokedDistributionCerts(certInfoFromApple, distCerts);
  }

  distCerts = options.filterInvalid && validDistCerts ? validDistCerts : distCerts;

  if (distCerts.length === 0) {
    _log().default.warn('There are no Distribution Certificates available in your expo account');

    return null;
  }

  const NONE_SELECTED = -1;
  const choices = distCerts.map((entry, index) => ({
    name: formatDistCert(entry, iosCredentials, getValidityStatus(entry, validDistCerts)),
    value: index
  }));
  choices.push({
    name: '[Go back]',
    value: NONE_SELECTED
  });
  const question = {
    type: 'list',
    name: 'credentialsIndex',
    message: 'Select certificate from the list.',
    choices
  };
  const {
    credentialsIndex
  } = await (0, _prompt().default)(question);

  if (credentialsIndex === NONE_SELECTED) {
    return null;
  }

  return distCerts[credentialsIndex];
}

function formatDistCertFromApple(appleInfo, credentials) {
  const userCredentials = credentials.userCredentials.filter(cred => cred.type == 'dist-cert' && cred.certId === appleInfo.id);
  const appCredentials = userCredentials.length !== 0 ? credentials.appCredentials.filter(cred => cred.distCredentialsId === userCredentials[0].id) : [];
  const joinApps = appCredentials.map(i => `      ${i.experienceName} (${i.bundleIdentifier})`).join('\n');
  const usedByString = joinApps ? `    ${_chalk().default.gray(`used by\n${joinApps}`)}` : `    ${_chalk().default.gray(`not used by any apps`)}`;
  const {
    name,
    status,
    id,
    expires,
    created,
    ownerName,
    serialNumber
  } = appleInfo;
  const expiresDate = (0, _dateformat().default)(new Date(expires * 1000));
  const createdDate = (0, _dateformat().default)(new Date(created * 1000));
  return `${name} (${status}) - Cert ID: ${id}, Serial number: ${serialNumber}, Team ID: ${appleInfo.ownerId}, Team name: ${ownerName}
    expires: ${expiresDate}, created: ${createdDate}
  ${usedByString}`;
}

function formatDistCert(distCert, credentials, validityStatus = 'UNKNOWN') {
  const appCredentials = credentials.appCredentials.filter(cred => cred.distCredentialsId === distCert.id);
  const joinApps = appCredentials.map(i => `${i.experienceName} (${i.bundleIdentifier})`).join(', ');
  const usedByString = joinApps ? `\n    ${_chalk().default.gray(`used by ${joinApps}`)}` : `\n    ${_chalk().default.gray(`not used by any apps`)}`;
  let serialNumber = distCert.distCertSerialNumber;

  try {
    if (!serialNumber) {
      serialNumber = _xdl().IosCodeSigning.findP12CertSerialNumber(distCert.certP12, distCert.certPassword);
    }
  } catch (error) {
    serialNumber = _chalk().default.red('invalid serial number');
  }

  let validityText;

  if (validityStatus === 'VALID') {
    validityText = _chalk().default.gray("\n    ✅ Currently valid on Apple's servers.");
  } else if (validityStatus === 'INVALID') {
    validityText = _chalk().default.gray("\n    ❌ No longer valid on Apple's servers.");
  } else {
    validityText = _chalk().default.gray("\n    ❓ Validity of this certificate on Apple's servers is unknown.");
  }

  return `Distribution Certificate (Cert ID: ${distCert.certId}, Serial number: ${serialNumber}, Team ID: ${distCert.teamId})${usedByString}${validityText}`;
}

async function generateDistCert(ctx) {
  await ctx.ensureAppleCtx();
  const manager = new (_appleApi().DistCertManager)(ctx.appleCtx);

  try {
    return await manager.create();
  } catch (e) {
    if (e.code === 'APPLE_DIST_CERTS_TOO_MANY_GENERATED_ERROR') {
      const certs = await manager.list();

      _log().default.warn('Maximum number of Distribution Certificates generated on Apple Developer Portal.');

      _log().default.warn(APPLE_DIST_CERTS_TOO_MANY_GENERATED_ERROR);

      const usedByExpo = ctx.ios.credentials.userCredentials.filter(cert => cert.type === 'dist-cert' && !!cert.certId).reduce((acc, cert) => ({ ...acc,
        [cert.certId || '']: cert
      }), {});
      const ui = new (_inquirer().default.ui.BottomBar)();
      ui.log.write('ℹ️ ℹ️ ℹ️ Show me more info about these choices ℹ️ ℹ️ ℹ️');
      ui.log.write('ℹ️ ℹ️ ℹ️ https://docs.expo.io/versions/latest/distribution/app-signing/#summary ℹ️ ℹ️ ℹ️');
      ui.log.write('\n');
      let {
        revoke
      } = await (0, _prompt().default)([{
        type: 'checkbox',
        name: 'revoke',
        message: 'Select certificates to revoke.',
        choices: certs.map((cert, index) => ({
          value: index,
          name: formatDistCertFromApple(cert, ctx.ios.credentials)
        })),
        pageSize: Infinity
      }]);

      for (const index of revoke) {
        const certInfo = certs[index];

        if (certInfo && usedByExpo[certInfo.id]) {
          await new RemoveIosDist(true).removeSpecific(ctx, usedByExpo[certInfo.id]);
        } else {
          await manager.revoke([certInfo.id]);
        }
      }
    } else {
      throw e;
    }
  }

  return await generateDistCert(ctx);
}

async function promptForDistCert(ctx) {
  const userProvided = await (0, _promptForCredentials().askForUserProvided)(_credentials().distCertSchema);

  if (userProvided) {
    try {
      userProvided.distCertSerialNumber = _xdl().IosCodeSigning.findP12CertSerialNumber(userProvided.certP12, userProvided.certPassword);
    } catch (error) {
      _log().default.warn('Unable to access certificate serial number.');

      _log().default.warn('Make sure that certificate and password are correct.');

      _log().default.warn(error);
    }

    return userProvided;
  } else {
    return null;
  }
}

async function validateDistributionCertificate(appleContext, distributionCert) {
  const spinner = (0, _ora().default)(`Checking validity of distribution certificate on Apple Developer Portal...`).start();
  const distCertManager = new (_appleApi().DistCertManager)(appleContext);
  const certInfoFromApple = await distCertManager.list();
  const validDistributionCerts = await filterRevokedDistributionCerts(certInfoFromApple, [distributionCert]);
  const isValidCert = validDistributionCerts.length > 0;

  if (isValidCert) {
    const successMsg = `Successfully validated Distribution Certificate against Apple Servers`;
    spinner.succeed(successMsg);
  } else {
    const failureMsg = `The Distribution Certificate is no longer valid on the Apple Developer Portal`;
    spinner.fail(failureMsg);
  }

  return isValidCert;
}

async function filterRevokedDistributionCerts(certInfoFromApple, distributionCerts) {
  if (distributionCerts.length === 0) {
    return [];
  } // if the credentials are valid, check it against apple to make sure it hasnt been revoked


  const validCertSerialsOnAppleServer = certInfoFromApple.filter( // remove expired certs
  cert => cert.expires > Math.floor(Date.now() / 1000)).map(cert => cert.serialNumber);
  const validDistributionCerts = distributionCerts.filter(cert => {
    const serialNumber = cert.distCertSerialNumber;

    if (!serialNumber) {
      return false;
    }

    return validCertSerialsOnAppleServer.includes(serialNumber);
  });
  return validDistributionCerts;
}

function sortByExpiryDesc(certInfoFromApple, distributionCerts) {
  return distributionCerts.sort((certA, certB) => {
    const certAInfo = certInfoFromApple.find(cert => cert.id === certA.certId);
    const certAExpiry = certAInfo ? certAInfo.expires : Number.NEGATIVE_INFINITY;
    const certBInfo = certInfoFromApple.find(cert => cert.id === certB.certId);
    const certBExpiry = certBInfo ? certBInfo.expires : Number.NEGATIVE_INFINITY;
    return certBExpiry - certAExpiry;
  });
}
//# sourceMappingURL=../../__sourcemaps__/credentials/views/IosDistCert.js.map
